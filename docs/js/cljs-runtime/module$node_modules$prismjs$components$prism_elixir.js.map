{
"version":3,
"file":"module$node_modules$prismjs$components$prism_elixir.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,oDAAA,CAAwE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CACrIC,KAAAC,UAAAC,OAAA,CAAyB,CAIxB,QAAW,CACVC,QAAS,sBADC,CAEVC,WAAY,CAAA,CAFF,CAJa,CASxB,MAAS,sIATe,CAUxB,OAAU,CACT,CAECD,QAAS,iJAFV;AAGCE,OAAQ,EAHT,CADS,CAQT,CACCF,QAAS,qBADV,CAECE,OAAQ,EAFT,CARS,CAcT,CAECF,QAAS,kCAFV,CAGCE,OAAQ,EAHT,CAdS,CAVc,CAgCxB,KAAQ,CAEPF,QAAS,cAFF,CAGPC,WAAY,CAAA,CAHL,CAIPE,MAAO,QAJA,CAhCgB,CAuCxB,YAAa,WAvCW,CAwCxB,QAAW,CAEVH,QAAS,wCAFC,CAGVC,WAAY,CAAA,CAHF,CAIVE,MAAO,UAJG,CAxCa,CA8CxB,SAAY,CAEXH,QAAS,cAFE,CAGXC,WAAY,CAAA,CAHD,CAIXE,MAAO,UAJI,CA9CY,CAoDxB,UAAa,CACZH,QAAS,QADG,CAEZG,MAAO,UAFK,CApDW,CAwDxB,OAAU,iEAxDc,CAyDxB,QAAW,yKAzDa;AA0DxB,UAAW,wBA1Da,CA2DxB,SAAY,CACX,0FADW,CAEX,CAECH,QAAS,cAFV,CAGCC,WAAY,CAAA,CAHb,CAFW,CAOX,CAECD,QAAS,cAFV,CAGCC,WAAY,CAAA,CAHb,CAPW,CA3DY,CAwExB,YAAe,qBAxES,CA2EzBJ,MAAAC,UAAAC,OAAAK,OAAAC,QAAA,CAAsC,QAAQ,CAACC,CAAD,CAAI,CACjDA,CAAAJ,OAAA,CAAW,CACV,cAAiB,CAChBF,QAAS,YADO,CAEhBE,OAAQ,CACP,UAAa,CACZF,QAAS,UADG,CAEZG,MAAO,aAFK,CADN,CAKPI,KAAMV,KAAAW,KAAAC,MAAA,CAAiBZ,KAAAC,UAAAC,OAAjB,CALC,CAFQ,CADP,CADsC,CAAlD,CA5EqI;",
"sources":["node_modules/prismjs/components/prism-elixir.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$prismjs$components$prism_elixir\"] = function(global,process,require,module,exports,shadow$shims) {\nPrism.languages.elixir = {\n\t// Negative look-ahead is needed for string interpolation\n\t// Negative look-behind is needed to avoid highlighting markdown headers in\n\t// multi-line doc strings\n\t'comment': {\n\t\tpattern: /(^|[^#])#(?![{#]).*/m,\n\t\tlookbehind: true\n\t},\n\t// ~r\"\"\"foo\"\"\", ~r'''foo''', ~r/foo/, ~r|foo|, ~r\"foo\", ~r'foo', ~r(foo), ~r[foo], ~r{foo}, ~r<foo>\n\t'regex': /~[rR](?:(\"\"\"|'''|[\\/|\"'])(?:\\\\.|(?!\\1)[^\\\\])+\\1|\\((?:\\\\\\)|[^)])+\\)|\\[(?:\\\\\\]|[^\\]])+\\]|\\{(?:\\\\\\}|[^}])+\\}|<(?:\\\\>|[^>])+>)[uismxfr]*/,\n\t'string': [\n\t\t{\n\t\t\t// ~s\"\"\"foo\"\"\", ~s'''foo''', ~s/foo/, ~s|foo|, ~s\"foo\", ~s'foo', ~s(foo), ~s[foo], ~s{foo}, ~s<foo>\n\t\t\tpattern: /~[cCsSwW](?:(\"\"\"|'''|[\\/|\"'])(?:\\\\.|(?!\\1)[^\\\\])+\\1|\\((?:\\\\\\)|[^)])+\\)|\\[(?:\\\\\\]|[^\\]])+\\]|\\{(?:\\\\\\}|#\\{[^}]+\\}|[^}])+\\}|<(?:\\\\>|[^>])+>)[csa]?/,\n\t\t\tinside: {\n\t\t\t\t// See interpolation below\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tpattern: /(\"\"\"|''')[\\s\\S]*?\\1/,\n\t\t\tinside: {\n\t\t\t\t// See interpolation below\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t// Multi-line strings are allowed\n\t\t\tpattern: /(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1/,\n\t\t\tinside: {\n\t\t\t\t// See interpolation below\n\t\t\t}\n\t\t}\n\t],\n\t'atom': {\n\t\t// Look-behind prevents bad highlighting of the :: operator\n\t\tpattern: /(^|[^:]):\\w+/,\n\t\tlookbehind: true,\n\t\talias: 'symbol'\n\t},\n\t// Look-ahead prevents bad highlighting of the :: operator\n\t'attr-name': /\\w+:(?!:)/,\n\t'capture': {\n\t\t// Look-behind prevents bad highlighting of the && operator\n\t\tpattern: /(^|[^&])&(?:[^&\\s\\d()][^\\s()]*|(?=\\())/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'argument': {\n\t\t// Look-behind prevents bad highlighting of the && operator\n\t\tpattern: /(^|[^&])&\\d+/,\n\t\tlookbehind: true,\n\t\talias: 'variable'\n\t},\n\t'attribute': {\n\t\tpattern: /@[\\S]+/,\n\t\talias: 'variable'\n\t},\n\t'number': /\\b(?:0[box][a-f\\d_]+|\\d[\\d_]*)(?:\\.[\\d_]+)?(?:e[+-]?[\\d_]+)?\\b/i,\n\t'keyword': /\\b(?:after|alias|and|case|catch|cond|def(?:callback|exception|impl|module|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|require|rescue|try|unless|use|when)\\b/,\n\t'boolean': /\\b(?:true|false|nil)\\b/,\n\t'operator': [\n\t\t/\\bin\\b|&&?|\\|[|>]?|\\\\\\\\|::|\\.\\.\\.?|\\+\\+?|-[->]?|<[-=>]|>=|!==?|\\B!|=(?:==?|[>~])?|[*\\/^]/,\n\t\t{\n\t\t\t// We don't want to match <<\n\t\t\tpattern: /([^<])<(?!<)/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\t// We don't want to match >>\n\t\t\tpattern: /([^>])>(?!>)/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'punctuation': /<<|>>|[.,%\\[\\]{}()]/\n};\n\nPrism.languages.elixir.string.forEach(function(o) {\n\to.inside = {\n\t\t'interpolation': {\n\t\t\tpattern: /#\\{[^}]+\\}/,\n\t\t\tinside: {\n\t\t\t\t'delimiter': {\n\t\t\t\t\tpattern: /^#\\{|\\}$/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\trest: Prism.util.clone(Prism.languages.elixir)\n\t\t\t}\n\t\t}\n\t};\n});\n\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","Prism","languages","elixir","pattern","lookbehind","inside","alias","string","forEach","o","rest","util","clone"]
}
