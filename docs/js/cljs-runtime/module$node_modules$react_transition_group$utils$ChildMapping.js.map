{
"version":3,
"file":"module$node_modules$react_transition_group$utils$ChildMapping.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,8DAAA,CAAkF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAG/ID,OAAAE,WAAA,CAAqB,CAAA,CACrBF,QAAAG,gBAAA,CAWAA,QAAwB,CAACC,QAAD,CAAW,CACjC,GAAI,CAACA,QAAL,CACE,MAAOA,SAET,KAAIC,OAAS,EACbC,OAAAC,SAAAC,IAAA,CAAoBJ,QAApB,CAA8B,QAAS,CAACK,KAAD,CAAQ,CAC7C,MAAOA,MADsC,CAA/C,CAAAC,QAAA,CAEW,QAAS,CAACD,KAAD,CAAQ,CAC1BJ,MAAA,CAAOI,KAAAE,IAAP,CAAA,CAAoBF,KADM,CAF5B,CAKA,OAAOJ,OAV0B,CAVnCL,QAAAY,mBAAA,CAwCAA,QAA2B,CAACC,IAAD,CAAOC,IAAP,CAAa,CAItCC,QAASA,eAAc,CAACJ,GAAD,CAAM,CAC3B,MAAIG,KAAAE,eAAA,CAAoBL,GAApB,CAAJ,CACSG,IAAA,CAAKH,GAAL,CADT,CAIOE,IAAA,CAAKF,GAAL,CALoB,CAH7BE,IAAA;AAAOA,IAAP,EAAe,EACfC,KAAA,CAAOA,IAAP,EAAe,EAYf,KAAIG,gBAAkB,EAAtB,CAEIC,YAAc,EAClB,KAASC,OAAT,GAAoBN,KAApB,CACMC,IAAAE,eAAA,CAAoBG,OAApB,CAAJ,CACMD,WAAAE,OADN,GAEIH,eAAA,CAAgBE,OAAhB,CACA,CAD2BD,WAC3B,CAAAA,WAAA,CAAc,EAHlB,EAMEA,WAAAG,KAAA,CAAiBF,OAAjB,CAIAG,KAAAA,QAAI,IAAK,EACb,KAAIC,aAAe,EAAnB,CACSC,OAAT,KAASA,OAAT,GAAoBV,KAApB,CAA0B,CACxB,GAAIG,eAAAD,eAAA,CAA+BQ,OAA/B,CAAJ,CACE,IAAKF,OAAL,CAAS,CAAT,CAAYA,OAAZ,CAAgBL,eAAA,CAAgBO,OAAhB,CAAAJ,OAAhB,CAAiDE,OAAA,EAAjD,CAEEC,YAAA,CAAaN,eAAA,CAAgBO,OAAhB,CAAA,CAAyBF,OAAzB,CAAb,CAAA,CAA4CP,cAAA,CADvBE,eAAA,CAAgBO,OAAhB,CAAAC,CAAyBH,OAAzBG,CACuB,CAGhDF,aAAA,CAAaC,OAAb,CAAA;AAAwBT,cAAA,CAAeS,OAAf,CAPA,CAW1B,IAAKF,OAAL,CAAS,CAAT,CAAYA,OAAZ,CAAgBJ,WAAAE,OAAhB,CAAoCE,OAAA,EAApC,CACEC,YAAA,CAAaL,WAAA,CAAYI,OAAZ,CAAb,CAAA,CAA+BP,cAAA,CAAeG,WAAA,CAAYI,OAAZ,CAAf,CAGjC,OAAOC,aA7C+B,CAtCxC,KAAIjB,OAASR,OAAA,CAAQ,iCAAR,CAPkI;",
"sources":["node_modules/react-transition-group/utils/ChildMapping.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$react_transition_group$utils$ChildMapping\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nexports.__esModule = true;\nexports.getChildMapping = getChildMapping;\nexports.mergeChildMappings = mergeChildMappings;\n\nvar _react = require('react');\n\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {*} children `this.props.children`\n * @return {object} Mapping of key to child\n */\nfunction getChildMapping(children) {\n  if (!children) {\n    return children;\n  }\n  var result = {};\n  _react.Children.map(children, function (child) {\n    return child;\n  }).forEach(function (child) {\n    result[child.key] = child;\n  });\n  return result;\n}\n\n/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */\nfunction mergeChildMappings(prev, next) {\n  prev = prev || {};\n  next = next || {};\n\n  function getValueForKey(key) {\n    if (next.hasOwnProperty(key)) {\n      return next[key];\n    }\n\n    return prev[key];\n  }\n\n  // For each key of `next`, the list of keys to insert before that key in\n  // the combined list\n  var nextKeysPending = {};\n\n  var pendingKeys = [];\n  for (var prevKey in prev) {\n    if (next.hasOwnProperty(prevKey)) {\n      if (pendingKeys.length) {\n        nextKeysPending[prevKey] = pendingKeys;\n        pendingKeys = [];\n      }\n    } else {\n      pendingKeys.push(prevKey);\n    }\n  }\n\n  var i = void 0;\n  var childMapping = {};\n  for (var nextKey in next) {\n    if (nextKeysPending.hasOwnProperty(nextKey)) {\n      for (i = 0; i < nextKeysPending[nextKey].length; i++) {\n        var pendingNextKey = nextKeysPending[nextKey][i];\n        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);\n      }\n    }\n    childMapping[nextKey] = getValueForKey(nextKey);\n  }\n\n  // Finally, add the keys which didn't appear before any key in `next`\n  for (i = 0; i < pendingKeys.length; i++) {\n    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n  }\n\n  return childMapping;\n}\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","__esModule","getChildMapping","children","result","_react","Children","map","child","forEach","key","mergeChildMappings","prev","next","getValueForKey","hasOwnProperty","nextKeysPending","pendingKeys","prevKey","length","push","i","childMapping","nextKey","pendingNextKey"]
}
