{
"version":3,
"file":"module$node_modules$redux$lib$createStore.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/redux/lib/createStore.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$redux$lib$createStore\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nexports.__esModule = true;\nexports.ActionTypes = undefined;\nexports['default'] = createStore;\n\nvar _isPlainObject = require('lodash/isPlainObject');\n\nvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\nvar _symbolObservable = require('symbol-observable');\n\nvar _symbolObservable2 = _interopRequireDefault(_symbolObservable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar ActionTypes = exports.ActionTypes = {\n  INIT: '@@redux/INIT'\n\n  /**\n   * Creates a Redux store that holds the state tree.\n   * The only way to change the data in the store is to call `dispatch()` on it.\n   *\n   * There should only be a single store in your app. To specify how different\n   * parts of the state tree respond to actions, you may combine several reducers\n   * into a single reducer function by using `combineReducers`.\n   *\n   * @param {Function} reducer A function that returns the next state tree, given\n   * the current state tree and the action to handle.\n   *\n   * @param {any} [preloadedState] The initial state. You may optionally specify it\n   * to hydrate the state from the server in universal apps, or to restore a\n   * previously serialized user session.\n   * If you use `combineReducers` to produce the root reducer function, this must be\n   * an object with the same shape as `combineReducers` keys.\n   *\n   * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n   * to enhance the store with third-party capabilities such as middleware,\n   * time travel, persistence, etc. The only store enhancer that ships with Redux\n   * is `applyMiddleware()`.\n   *\n   * @returns {Store} A Redux store that lets you read the state, dispatch actions\n   * and subscribe to changes.\n   */\n};function createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.');\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.');\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n  function getState() {\n    return currentState;\n  }\n\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected listener to be a function.');\n    }\n\n    var isSubscribed = true;\n\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      isSubscribed = false;\n\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing \u201cwhat changed\u201d. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  function dispatch(action) {\n    if (!(0, _isPlainObject2['default'])(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.');\n    }\n\n    currentReducer = nextReducer;\n    dispatch({ type: ActionTypes.INIT });\n  }\n\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== 'object') {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return { unsubscribe: unsubscribe };\n      }\n    }, _ref[_symbolObservable2['default']] = function () {\n      return this;\n    }, _ref;\n  }\n\n  // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT });\n\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[_symbolObservable2['default']] = observable, _ref2;\n}\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","createStore","reducer","preloadedState","enhancer","subscribe","listener","Error","isSubscribed","nextListeners","currentListeners","slice","push","unsubscribe","index","indexOf","splice","dispatch","action","_isPlainObject2","type","isDispatching","currentState","currentReducer","listeners","i","length","_ref2","undefined","ActionTypes","INIT","getState","replaceReducer","nextReducer","_symbolObservable2","observable","_ref","observer","observeState","next","TypeError","__esModule","_isPlainObject","_symbolObservable"]
}
